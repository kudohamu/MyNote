冗長化（Redundancy）
======
障害が発生しても予備の機材でシステムの機能を継続できるようにすること。  
1. 障害を想定する  
2. 障害に備えて予備の機材を準備する  
3. 障害が発生した際に予備の機材に切り替えられる運用体制を整備する  

####ルータが故障した場合の対応
**コールドスタンバイ**によってルータが故障したとしても線を繋ぎ替えるだけで簡単に復旧できる。  
冗長化されたシステムでは現用機と予備機の設定は常に同じにしていなければならない。  

####Webサーバが故障した場合の対応
**ホットスタンバイ**によって現用機の内容を更新する際に予備機にも同じ更新がかかるようにしておき、現用機に何か起こった場合にすぐ予備機に切り替えられるようにしておくことですぐに復旧できる。  

##Webサーバの冗長化構成
###DNSラウンドロビン  
DNSを利用して一つのサービスに複数台のサーバを分散させる手法  
DNSサーバは同じ名前に複数のレコードが登録されると問い合わせの度に異なる結果を返す。この動作を利用することで、複数台のサーバに処理を分散させることができる。  
* DNSラウンドロビンは負荷分散のための仕組みであり、冗長化の仕組みではない  
  * [ヘルスチェック](./redundancy.md#%E3%83%98%E3%83%AB%E3%82%B9%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF)や[フェイルオーバ](./redundancy.md#%E3%83%95%E3%82%A7%E3%82%A4%E3%83%AB%E3%82%AA%E3%83%BC%E3%83%90)は別途実装しないといけない  
* サーバの数だけグローバルアドレスが必要  
  * たくさんのサーバで負荷分散するためにはIPアドレスをたくさん取得できるサービス（回線）を利用する必要がある  
* 均等に分散されるとは限らない  
  * PC用ブラウザでDNSレコードの問い合わせをキャッシュされる  
  * 携帯電話からのアクセスは__キャリアゲートウェイ__と呼ばれるプロキシサーバを経由するが、プロキシサーバでも名前解決の結果がしばらくの間キャッシュされる  
  * DNSレコードの__TTL（Time To Live）__を短く設定することである程度改善できる可能性がある  
* サーバがダウンしても気づかない
  * DNSサーバはWebサーバの負荷や接続数などに応じて問い合わせ結果をコントロールすることができない  
  * ダウンしたサーバに分散されたユーザはエラーページを見ることになる  

#####DNSラウンドロビンで冗長化を図るには  
* 各Webサーバに[VIP](./)を持たせる  
  * サーバごとにVIPが必要  
* web1が停止するとVIP1がweb2に引き継がれてすべてのアクセスをweb2が処理するようにする（反対も同様）  
* pingではなくcurlを使ってフェイルオーバを実現する  
* VIPに対するヘルスチェックが失敗した場合  
  * それが自分に対して割り当てられているアドレスなら、自分のwebサービスに異常が発生したとみなしてVIPを開放する  
  * 自分に割り当てられているアドレスでなければ、相手のwebサービスに異常が発生したとみなして自分がVIPを引き継ぐ  

#####問題点
サーバが3台以上になると
* どのサーバが落ちた時にどのサーバがVIPを引き継ぐのか不安  
* フェイルオーバのタイミングによっては2台のサーバが同じIPアドレスを持つ可能性がある  
* 一度停止したサーバを復帰させるのが困難  

###ロードバランサ
1つのIPアドレスに対するリクエストを複数のサーバへ分散することができる  
#####ロードバランス（負荷分散：Load Balance）とは  
複数台のサーバに処理を分散させてサイト全体のスケーラビリティを向上させる仕組み  
* サーバを負荷分散構成にすると、将来アクセス数が増えてサーバの処理が追いつかなくなってもサーバを増設することで対応できる  
* 古いサーバが無駄になることもない  

####ロードバランサの動作  
* ロードバランサはサービス用のグローバルアドレスをもった仮想的なサーバとして動作する  
* クライアントから送られてきたリクエストを本物のWebサーバへ中継することであたかも自分がWebサーバであるかのように振る舞う  

####ロードバランサの機能
* ロードバランサは複数台のリアルサーバの中から1台を選択して処理を中継する  
* その際、ヘルスチェックが失敗しているサーバは選択せず、必ずヘルスチェックが成功しているサーバを選択する  
* 1台のサーバが停止していても正常に稼働しているサーバがある限りサービスが停止することはない  

##重要な用語
###フェイルオーバ
現用機に障害が発生した際に自動的に処理を予備機に引き継ぐこと。  
* サーバをフェイルオーバする際には[VIP（Virtual IP Address）](./)と[IPアドレスの引き継ぎ](./redundancy.md#ip%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%81%AE%E5%BC%95%E3%81%8D%E7%B6%99%E3%81%8E)を利用する  
  * 現用機に自分のIPアドレスとは別にVIPを割り当てておき、WebサービスはVIPで提供するようにする  
  * 現用機に障害が発生した場合は予備機がVIPを引き継ぐ  
* 正常にフェイルオーバするには[ヘルスチェック](./redundancy.md#%E3%83%95%E3%82%A7%E3%82%A4%E3%83%AB%E3%82%AA%E3%83%BC%E3%83%90)が必要である  

###ヘルスチェック  
現用機で障害が発生していることを検出する仕組み。  
* __ICMP監視（レイヤ3）__  
  * ICMP監視はICMPのechoリクエストを投げてリプライが返ってくるかをチェックする  
  * 最も簡単で軽いヘルスチェックだが、Webサービスがダウンした場合は検知できない  
  * __ルータのヘルスチェック__に向いている（ルータに対してICMP監視を行うのではなく、Webサーバに対して行う）  
* __ポート監視（レイヤ4）__  
  * ポート監視はTCPで接続を試み、接続できるかどうかをチェックする  
  * Webサービスがダウンしたことは検知できるが、過負荷状態で応答できなくなっていたりエラーを返していることは検知できない  
* __サービス監視（レイヤ7）__
  * 実際にHTTPリクエストなどを発行し正常な応答が返ってくるかどうかをチェックする  
  * ほとんどの異常を検知することができるが、場合によってはサーバに負担をかけてしまう  
  * __Webサーバのヘルスチェック__に向いている  

###IPアドレスの引き継ぎ
* LAN（Ethernet）の世界ではIPアドレスではなくNIC固定のMACアドレスを使って通信をしている  
* 他のサーバにパケットを送る際にはMACアドレスを取得するために__ARP（Address Resolution Protocol）__を使う  
* IPアドレスを引き継ぐためには他のサーバのARPテーブルのキャッシュを更新してもらわないといけない  
* __GARP（gratuitous ARP）__で更新のための通知ができる  

###スケジューリングアルゴリズム  
リアルサーバに処理を分散する際、すべてのサーバへ均等に分散してしまうとスペックの異なるサーバが混在している環境では負荷が偏ってしまう恐れがある。  
環境に適したスケジューリングアルゴリズムを組み込むことで適切な負荷分散を行える。  

主なスケジューリングアルゴリズム  
| 名称 | 動作 |  
| ---- | ---- |  
| rr(round-robin) | (何も考えずに)リアルサーバを先頭から順に選択していく。すべてのサーバに均等に処理が分散される。 |
| wrr(weighted round-robin) | rrと同じだが、重みを加味しながら分散比率を変える。重みが大きなサーバほど頻繁に選択されるので、処理能力の高いサーバは重みを大きくすると良い。 |
| lc(least-connection) | コネクション数が一番少ないサーバを選択する。ほとんどの場合はこれで問題ない。どのアルゴリズムを使えばいいのか分からない場合に使っても良い。 |
| wlc(weighted least-connection) | lcと同じだが、重みを加味する。具体的には「（コネクション数＋1）÷重み」が最小となるサーバを選択するので、高性能なサーバは重みを大きくすると良い。 |
| sed(shortest expected delay) | 最も応答速度が速いサーバを選択するが、サーバにパケットを飛ばして応答時間を計測しているわけではない。ステートがESTABLISHEDなコネクション数が一番少ないサーバを選択しているだけ。wlcとほとんど同じ動作になるが、wlcではESTABLISHED以外のステート（TIME_WAITやFIN_WAITなど）のコネクション数を加味している点が異なる。 |
| nq(never queue) | sedと同じアルゴリズムだが、アクティブコネクション数が0のサーバを再優先で選択する。 |
| sh(source hashing) | 送信元のIPアドレスからハッシュ値を計算して分散先のリアルサーバを選択する。 |
| dh(destination hashing) | 宛先のIPアドレスからハッシュ値を計算して分散先のリアルサーバを選択する。 |
| lblc(locality-based least-connection) | コネクション数が「重み」で指定した値を超えるまでは同じサーバを選択する。コネクション数が「重み」で指定した値を超えた場合は別なサーバを選択する。すべてのサーバのコネクション数が「重み」で指定した値を超えている場合、最後に選択されたサーバが選択され続ける。 |
| lblcr(locality-based least-connection with replication) | lblcとほとんど同じだが、すべてのサーバのコネクション数が「重み」で指定した値を超えている場合は、コネクション数が一番少ないサーバが選択される。 |

###IPVS
