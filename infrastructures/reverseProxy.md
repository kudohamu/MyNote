リバースプロキシ
======

リバースプロキシはクライアントとWebサーバの間に入り、柔軟な負荷分散を可能にする。  
リバースプロキシによってクライアントからの要求がWebサーバへ届く途中の処理に割って入って様々な前後処理を施すことができる。  
Apache, lighttpd, Squidなどにmod_proxyやmod_proxy_balancerを組み込んで構築することができる  

##リバースプロキシ導入のメリット  
####HTTPリクエストの内容に応じたシステムの動作の制御  
リバースプロキシがあると、HTTPリクエストの中からURLを見て  
* クライアントから要求されたURLが`/images/logo.jpg`なら画像用のWebサーバに  
* クライアントから要求されたURLが`/news`であれば動的コンテンツを生成するWebサーバに  
と、最終的な処理をそれぞれ別のWebサーバに振り分けるようなL7的な制御が可能になる。  

Apcheではmod_rewriteの__RewriteRule__機能を使用することになるがこれにより

* クライアントのIPアドレスを見て特定のIPアドレスからのみサーバへのアクセスを許可したり、弾いたりする  
* クライアントのIPアドレスを見て特定のIPアドレスからのみ管理者ページにアクセスできるようにする  
* クライアントのUser-Agentを見て、検索エンジンのロボットの場合はキャッシュサーバを経由してWebサーバへアクセスさせる  
* `hoge/foo/bar`というURLを`/hoge?foo=bar`というURLに変更してからWebサーバへリクエストする

などといったことが可能になる。

####システム全体のメモリ使用効率の向上  
動的コンテンツを返却するWebサーバは通常、アプリケーションが利用するプログラムをメモリに常駐させることでアプリケーション起動時のオーバヘッドを回避する設計がされている。Webサーバはこの都合上、静的コンテンツを返却するだけのWebサーバに比べて動的コンテンツを返却するAPサーバが数倍〜数十倍のメモリを消費することも珍しくない。  

また、通常APサーバはクライアント1リクエストに対して1プロセスもしくは1スレッドを割り当てて処理する方式を取っている。それぞれのプロセス/スレッドは他のプロセス/スレッドとは独立して動作する。  
しかし、APサーバが1リクエストに対して1リクエストに対して1プロセス/スレッドで応答すると、ファイルに書かれた内容をそのまま返却するだけでよいような静的コンテンツに対しても同様の方式で返却することになる。  

そこで静的なファイルを返却するWebサーバと、動的なコンテンツを生成するAPサーバを別のサーバとして切り分け、リバースプロキシにより  
* リクエストされたURLが/image以下やCSSなど、静的コンテンツを配備したパス以下である場合は__Webサーバ__へ  
* それ以外のURLの場合は動的コンテンツの要求なので__APサーバ__へ
とURLの内容によって振り分け先を変更できる。  
このとき、リバースプロキシ自身もWebサーバであるという特徴を生かして（静的コンテンツを返却するためにWebサーバを別途用意するのではなく）静的コンテンツはリバースプロキシ自身が返却する、という構成が一般的である。  

####Webサーバが応答するデータのバッファリングの役割  
1プロセスあたりのメモリ消費が多いAPサーバでは1つのホスト内で立ち上げられる最大プロセス数はせいぜい50~100本である。  
リバースプロキシなしでKeep-Aliveを有効にした場合は、この50~100本といった少ないプロセスの多くがKeep-Aliveの接続の維持のために消費されてしまう。  
リバースプロキシ役のWebサーバはプロセスあたりのメモリ消費量が少なく、1つのホスト内で1,000~10,000プロセスを立ちあげられるので__クライアントとリバースプロキシの間のみ「Keep-Aliveオン」__にして、__リバースプロキシとバックエンドのAPサーバ間は「Keep-Aliveオフ」__にすると良い。  

####Apacheモジュールを利用した処理の制御  
リバースプロキシにApacheを採用すると、Apacheモジュールを組み込んでHTTPリクエストの前処理/後処理に任意のプログラムを動かすことが可能になる。  
たとえばコンテンツをgzip圧縮したり、APサーバからの応答をSSLで暗号化したり、DoS攻撃対策用モジュールを使って特定クライアントからの過剰なアクセスを一時的に遮断したりすることが可能になる。 

